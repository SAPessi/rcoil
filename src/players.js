/*
 * Copyright 2016 Stefano Buliani (@sapessi)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// core modules
var http = require('http');
var https = require('https');
var util = require('util');
var events = require('events');

// external modules
var AWS = require('aws-sdk');

// local modules
var Request = require('./request');

/**
 * RequestPlayer executes requests configured in a request group. The RequestPlayer 
 * can execute both HTTP and Lambda requests. This object is used internally by the 
 * RequestGroupPlayer and there should be no need to interact with it from the outside.
 * 
 * RequestPlayer is an EventEmitter.
 * 
 * @class
 * @constructor
 * @param {Object} request - A configured Request object
 * @param {Object} context - An initialized ExecutionContext object to keep state across multiple executions
 * @param {Object} options - The options passed to the director
 * 
 * @fires RequestPlayer#start
 * @fires RequestPlayer#end
 * @fires RequestPlayer#abort
 */
function RequestPlayer(request, context, options) {
  this.request = request;
  this.options = options;
  this.requestObject = null;
  
  this._context = context;

  events.EventEmitter.call(this);
}
util.inherits(RequestPlayer, events.EventEmitter);

/**
 * The start event is fired whenever the RequestPlayer begins executing a request
 * 
 * @event RequestPlayer#start
 * @type {Object}
 * @property {Object} requestConfig - The original configuration for the request object
 * @property {Object} request - The initialized http.ClientRequest object
 * @property {*} input - The input generated by the callback function configured in the request object
 */

/**
 * The end event is fired whenever the RequestPlayer completes the execution of a request
 * 
 * @event RequestPlayer#end
 * @type {Object}
 * @property {Object} requestConfig - The original configuration for the request object
 * @property {Object} response - The received http.IncomingMessage object
 * @property {String} output - The response body
 */

/**
 * The abort event is fired whenever the RequestPlayer aborts an HTTP request
 * 
 * @event RequestPlayer#abort
 * @type {Object}
 * @property {Object} requestConfig - The original configuration for the request object
 */

/**
 * The cancel event is fired whenever the onInput method of the requestConfig returns false
 * 
 * @event RequestPlayer#cancel
 * @type {Object}
 * @property {Object} requestConfig - The original configuration for the request object
 */

/**
 * Executes a Request object. This method runs the input callback to retrieve the request data
 * then fires the relevant executor based on the request type.
 * 
 * @function
 * @private
 * @param {Object} requestConfig - An initialized Request object
 */
RequestPlayer.prototype._executeRequest = function (requestConfig) {
  if (this.options.debug) this.options.logger.debug("starting execution for request: " + requestConfig.name);

  switch (requestConfig.type) {
    case Request.RequestType.HTTP:
      this._executeHttpRequest(requestConfig);
      break;
    case Request.RequestType.LAMBDA:
      this._executeLambdaRequest(requestConfig);
      break;
  }
};

/**
 * Uses the callback function configured in the request configuration (onInput) to 
 * generate the request body. If it's an HTTP request the callback receives both the
 * context and the http.ClientRequest object. For LAMBDA invokes it only sends the 
 * context.
 * 
 * @function
 * @private
 * @param {Request} requestConfig - An initialized Request object
 * @param {http.ClientRequest} requestObject - The request object generated by the HTTP client
 */
RequestPlayer.prototype._getRequestInput = function(requestConfig, requestObject) {
  var requestInput = null;

  if (requestConfig.inputFunc !== undefined && requestConfig.inputFunc != null) {
    var tmpTimer = Date.now();
    switch (requestConfig.type) {
      case Request.RequestType.HTTP:
        requestInput = requestConfig.inputFunc(this._context, requestObject);
        break;
      case Request.RequestType.LAMBDA:
        requestInput = requestConfig.inputFunc(this._context);
        break;
    }
    tmpTimer = Date.now() - tmpTimer;

    if (this.options.debug) this.options.logger.debug("Input function for " + requestConfig.name + " execution: " + tmpTimer + "ms");
    
    return requestInput;
  }
}

/**
 * Executes a Lambda function using the AWS SDK for Node.js. The SDK can be initialized
 * using a configuration object passed to the ExecutionDirector in the awsConfig property
 * of the options.
 * 
 * @function
 * @private
 * @param {Request} requestConfig - A Request object containing the Lambda function settings 
 */
RequestPlayer.prototype._executeLambdaRequest = function(requestConfig) {
  if (this.options.awsConfig != null) {
    AWS.config = this.options.awsConfig;
  }
  
  var input = this._getRequestInput(requestConfig)
  
  if (input === false) {
    localThis.emit("cancel", requestConfig);
    return;
  }
  
  var lambda = AWS.Lambda({apiVersion: '2015-03-31'});
  var functionConfig = {
    FunctionName: requestConfig.settings.function,
    InvocationType: "RequestResponse",
    Payload: new Buffer(input),
    Qualifier: requestConfig.settings.qualifier
  };
  var localThis = this;
  
  lambda.invoke(functionConfig, function(err, data) {
    if (err) // TODO: is this the right thing to do?!
      data = err;
      
    localThis.emit("end", requestConfig, err, data);
  });
}

/**
 * Executes an HTTP Request object. This method uses the default nodejs http and https modules
 * to execute HTTP requests. Once the request is completed this method fires the RequestPlayer#end
 * event.
 * 
 * @function
 * @private
 * @param {Object} requestConfig - An initialized Request object
 */
RequestPlayer.prototype._executeHttpRequest = function (requestConfig) {
  var httpClient = http;
  if (requestConfig.settings.protocol == "https:") {
    httpClient = https;
  }

  var localThis = this;
  var tmpTimer = Date.now();

  this.requestObject = httpClient.request(requestConfig.settings, function (response) {
    var resp = "";
    response.on("data", function (chunk) {
      resp += chunk;
    });

    response.on("end", function () {
      tmpTimer = Date.now() - tmpTimer;
      
      localThis.emit("end", requestConfig, response, resp);
    })
  });

  var input = this._getRequestInput(requestConfig, this.requestObject);
  if (input === false) {
    localThis.emit("cancel", requestConfig);
    return;
  }

  if (input != null) {
    this.requestObject.write((typeof input === 'object') ? JSON.stringify(input) : input);
  }
  tmpTimer = Date.now();
  this.emit("start", requestConfig, this.requestObject, input);
  
  this.requestObject.on("abort", function () {
    localThis.emit("abort", this.requestObject);
  })
  this.requestObject.end();
};

/**
 * Starts the execution of the Request
 * 
 * @function
 */
RequestPlayer.prototype.start = function () {
  this._executeRequest(this.request);
};

/**
 * Aborts the execution of the request
 * 
 * @function
 */
RequestPlayer.prototype.abort = function () {
  if (this.requestObject != null) {
    this.requestObject.abort();
  }
};


/**
 * The request group player monitors the execution of a groups of requests and reports
 * the status through its events. The ExecutionDirector object receives the notifications
 * from the RequestGroupPlayer and updates the ExecutionContext
 * 
 * @class
 * @constructor
 * @param {Object} requestGroup - The request group object to be executed
 * @param {ExecutionContext} context - The current execution context
 * @param {Object} options - Configuration options for the player 
 * 
 * @fires RequestGroupPlayer#start
 * @fires RequestGroupPlayer#end
 * @fires RequestGroupPlayer#requestStart
 * @fires RequestGroupPlayer#requestEnd
 */
function RequestGroupPlayer(requestGroup, context, options) {
  this.requestGroup = requestGroup;
  this.options = options;
  
  this._context = context;
  this._requestsCount = 0;
  this._tmpRequests = 0;
  this._requests = [];
  
  events.EventEmitter.call(this);
}
util.inherits(RequestGroupPlayer, events.EventEmitter);

/**
 * The start event is fired whenever the RequestGroupPlayer begins executing a group
 * 
 * @event RequestGroupPlayer#start
 * @type {Object}
 * @property {Object} requestGroup - The request group object that is being executed
 */

/**
 * The end event is fired whenever the RequestGroupPlayer completes the execution of a group
 * 
 * @event RequestGroupPlayer#end
 * @type {Object}
 * @property {Object} requestGroup - The completed request group object
 */

/**
 * The requestStart event is fired whenever the RequestGroupPlayer sends the start command
 * to a RequestPlayer object
 * 
 * @event RequestGroupPlayer#requestStart
 * @type {Object}
 * @property {Object} requestGroup - The completed request group object
 * @property {Request} requestConfig - The request configuration passed to the RequestPlayer
 * @property {http.ClientRequest} requestObject - The node.js http/s request object
 * @property {*} input - The input generated for the request by the callback function
 */

/**
 * The requestEnd event is fired whenever the RequestPlayer completes the execution
 * of a request
 * 
 * @event RequestGroupPlayer#requestEnd
 * @type {Object}
 * @property {Object} requestGroup - The completed request group object
 * @property {Request} requestConfig - The request configuration passed to the RequestPlayer
 * @property {http.IncomingMessage} response - The response object from the node.js http/s client
 * @property {*} output - The output returned from the remote server
 */

/**
 * The requestCancel event is fired whenever the onInput function for a request returns false
 * 
 * @event RequestGroupPlayer#requestCancel
 * @type {Object}
 * @property {Object} requestGroup - The completed request group object
 * @property {Request} requestConfig - the request configuration for the request that is being canceled
 */

/**
 * Returns an intialized RequestPlayer object with all of the events connected to callbacks. The
 * connections here are used to propagate events up to the ExecutionDirector.
 * 
 * @function
 * @private
 * @param {Request} request - The request configuration
 * @param {ExecutionContext} context - The current execution context
 * @param {Object} options - The options for the RequestPlayer object
 * 
 * @return {RequestPlayer} An initliazed RequestPlayer object
 */
RequestGroupPlayer.prototype._getRequestPlayer = function (request, context, options) {
  var newRequest = new RequestPlayer(request, context, options);
  var localThis = this;
  newRequest.on("start", function (requestConfig, requestObject, input) {
    localThis.emit("requestStart", localThis.requestGroup, requestConfig, requestObject, input);
  });
  newRequest.on("end", function (requestConfig, response, output) {
    localThis.emit("requestEnd", localThis.requestGroup, requestConfig, response, output);

    localThis._incrementRequests();
  });
  newRequest.on("cancel", function(requestConfig) {
    localThis.emit("requestCancel", localThis.requestGroup, requestConfig);
    
    localThis._incrementRequests();
  });

  return newRequest;
};

/**
 * Utility method that increments the local counter of executed requests and emits the end
 * event for the request group if necessary
 * 
 * @function
 * @private
 */
RequestGroupPlayer.prototype._incrementRequests = function() {
    this._tmpRequests++;
    
    if (this._tmpRequests == this._requestsCount) {
      this.emit("end", this.requestGroup);
    }
}

/**
 * Starts the execution of a request group. All of the request objects configured within the group are
 * started at the same time.
 * 
 * @function
 * @private
 * @param {Object} requestGroup - The request group object from the Rcoil tree.
 */
RequestGroupPlayer.prototype._startRequestGroup = function (requestGroup) {
  this.emit("start", requestGroup);
  this._tmpRequests = 0;
  this._requestsCount = requestGroup.requests.length;
  
  for (var i = 0; i < requestGroup.requests.length; i++) {
    var newRequest = this._getRequestPlayer(requestGroup.requests[i], this._context, this.options);

    this._requests.push(newRequest);
    newRequest.start();
  }
};

/**
 * Starts the execution of a request group object from the Rcoil tree.
 */
RequestGroupPlayer.prototype.start = function () {
  this._startRequestGroup(this.requestGroup);
}

module.exports = {
  RequestPlayer: RequestPlayer,
  RequestGroupPlayer: RequestGroupPlayer
}
